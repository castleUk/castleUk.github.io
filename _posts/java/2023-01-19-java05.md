---
published: true
title : "[이것이 자바다] 자바 Reminding(5) - 상속"
categories:
  - Java
tags:
  - Study
  - Java
toc: true
toc_sticky: true
sidebar:
    nav: "sidebar-category"
---

#  [7장] 상속

## 7.1 상속 개념
&nbsp; `상속`은 부모가 자식에세 물려주는 행위를 말한다.  OOP에서도 부모 클래스의 필드와 메소드를 자식 클래스에게 물려줄 수 있다. 이미 잘 개발된 클래스를 재사용해서 코드의 중복을 줄이고 개발 시간을 단축시킨다.
<br>
<br>
 
```
public class A{
  int field1;
  void method1(){...}
}

public class B extends A //A를 상속
  String field2;
  void method2(){...}

B b = new B();
b.field1 = 10; //A로 부터 물려 받은 필드
b.method1(); // A로 부터 물려 받은 메소드

b.field2 = "홍길동";
method2();
```

## 7.2 클래스 상속
&nbsp; 현실에서는 상속은 부모가 자식을 선택하지만, 프로그램에서는 자식이 부모를 선택한다. 자식 클래스명 뒤에 extends 부모클래스를 기술한다.
<center>주의!  자바는 다중 상속을 허용하지 않는다.</center>
<br>

## 7.3 부모 생성자 호출
&nbsp; 자바에서는 자식 객체를 생성하면 부모 객체가 먼저 생성된 다음에 자식 객체가 생성된다. 모든 객체는 생성자를 호출해야만 생성된다. 부모 객체의 생성자는 자식 생성자의 맨 첫 줄에 숨겨져 있는 `super()` 에 의해서 호출된다.
<br>
<br>

## 7.4 메소드 재정의
&nbsp; 부모 클래스의 모든 메소드가 자식 클래스에게 맞게 설계되어 있다면 가장 이상적인 상속이지만, 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않을 수 있다. 이러한 메소드는 자식 클래스에서 재정의해서 사용해야 한다. 이것을 `메소드 오버라이딩` 이라고 한다.
<br>
<br>

### <center>메소드 오버라이딩</center>
&nbsp; 상속된 메소드를 자식 클래스에서 재정의하는 것을 말한다. 메소드가 오버라이딩되면 부모 메소드는 숨겨지고, 자식 메소드가 우선적으로 사용됨

```
class Parent{
  void method1(){...}
}

class Child extends Parent{
  void method1(){...}
}

class ChildExample{
  public static void main(String[] args){
    
    Child child = new Child();

    child.method1(); // 상속 받은 메소드1이 아닌 자식이 재정의한 메소드1이 실행됨
  }
}
```

<br>
<br>

### <center>부모 메소드 호출</center>
&nbsp; 부모 메소드가 100줄의 코드를 가지고 있을경우, 자식 메소드에서 1줄만 추가하고 싶더라도 100줄의 코드를 자식 메소드에서 다시 작성해야 한다. 이러한 문제를 해결하기 위해 `공동작업처리기법`을 이용한다.

```
class Parent{
  public void method(){
    //작업처리1
  }
}

class Child extends Parent{
  @Override
  void method(){
    super.method(); //부모 메소드 호출
    //작업처리2
  }
}
```
<br>

## 7.5 final 클래스와 final 메소드
&nbsp; 필드 선언 시에 final을 붙이면 초기값 설정 후 값을 변경할 수 없다. 그렇다면 클래스와 메소드에 final을 붙이면 어떻게 될까?
<br>
<br>


### <center>final 클래스, 메소드</center>
&nbsp; 클래스및 메소드 선언시 final 키워드를 앞에 붙이면 `최종적인 클래스 or 메소드`가 된다. 클래스의 경우  상속할 수 없는 클래스가 된며 메소드의 경우 오버라이딩할수 없는 상태가 된다.즉 final 클래스는 부모 클래스가 될수 없어 자식 클래스를 만들수 없으며, final메소드는 재정의 할수 없다.
<br>
<br>

## 7.6 protected 접근 제한자
&nbsp; protected 접근 제한자는 상속과 관련이 있고, public과 default의 중간쯤에 해당하는 접근 제한을 한다.
<br>
<br>
|접근제한자|제한 대상|제한 범위|
|--|--|--|
|protected|필드, 생성자, 메소드| 같은 패키지이거나, 자식 객체만 사용 가능|
<br>
<br>
protected는 같은 패키지에서는 접근이 가능하나, 다른 패키지에서는 자식 클래스만 접근을 허용한다.
<br>
<br>

## 7.7 타입 변환
&nbsp; 타입 변환이란 타입을 다른 타입으로 변환하는 것을 말한다. 클래스도 마찬가지로 타입 변환이 있는데, 클래스의 타입 변환은 상속 관계에 있는 클래스 사이에서 일어난다.
<br>
<br>

### <center>자동 타입 변환</center>
&nbsp; 자동 타입 변환은 의미 그대로 자동적으로 타입변환이 일어나는 것을 말한다.

```
부모타입 변수 = 자식타입객체;
// 자동 타입 변환이 일어난다.
```
자식은 부모의 특징과 기능을 상속받기 떄문에 부모와 동일하게 취급 될수 있다. 예를 들어 고양이가 동물의 기능과 특징을 상속 받았다면, 고양이는 동물이다. 가 성립함


tip. 부모 타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메소드만 접근이 가능하다. 그러나 자식 클래스에서 오버라이딩된 메소드가 있다면 부모 메소드 대신 오버라이딩된 메소드가 호출된다. 이것은 `다형성`과 관련이 있다.
<br>
<br>


### <center>강제 타입 변환</center>
&nbsp; 자식 타입은 부모 타입으로 자동 변환되지만, 반대로 부모 타입은 자식 타입으로 자동 변환되지 않는다. 대신 다음과 같이 캐스팅 연산자로 강제 타입 변환을 할수 있다.

```
자식타입 변수 = (자식타입) 부모타입객체;
```
자식 객체가 부모 타입으로 자동 변환하면 부모 타입의 필드와 메소드만 사용 가능하다는 제약 사항이 따른다. 만약 자식 타입에 선언된 필드와 메소드를 꼭 다시 사용해야 한다면 강제 타입 변환을 해서 다시 자식 타입으로 변환해야 한다.
<br>
<br>


## 7.8 다형성
&nbsp; 다형성이란 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질을 말한다. 자동차의 부품을 교환하면 성능이 다르게 나오듯이 객체는 부품과 같아서, 프로그램을 구성하는 객체를 바꾸면 프로그램의 실행 성능이 다르게 나올수 있다.
<br>
&nbsp; 객체 사용 방법이 같다는 것은 동일한 메소드를 가지고 있다는 뜻이다. 두 객체가 같은 부모의 메소드를 오버라이딩하고 있다면, 메소드 호출시 서로 다르게 오버라이딩된 결과가 나올 것이다. 이것이 바로 다형성이다.
<br>
<br>

### <center>필드 다형성</center>
&nbsp; 필드 다형성은 필드 타입은 동일하지만, 대입되는 객체가 달라져서 실행 결과가 다양하게 나올수 있는 것을 말한다.
```
public class Car{
  //필드 선언
  public Tire tire;

  //메소드 선언
  public void run(){
    tire.roll();
  }
}

Car myCar = new Car();

mrCar.tire = new HankookTire();

mrCar.tire = new KumhoTire();

mrCar.run(); //장착된 타이어의 roll() 메소드 호촐, 어떤 타이어가 장착 했는지에 따라 roll의 결과가 달라질것이다.
```
<br>
<br>


### <center>매개변수 다형성</center>
&nbsp; 다형성은 필드보다는 메소드를 호출할 때 많이 발생한다. 메소드가 클래스 타입의 매개변수를 가지고 있을경우, 호출할 때 동일한 타입의 객체를 제공하는 것이 정석이지만 자식 객체를 제공할 수도 있따. 여기서 다형성이 발생한다.

```
public class Driver{
  public void drive(Vehicle vehicle){
    vehicle.run();
  }
}

Driver driver = new Driver();
Vehicle vehicle = new Vehicle();
driver.drive(vehicle);
// 매개값에 Vehicle의 자식 개체도 제공할수 있음<br>
// 따라서 자식 객체의 run() 메소드를 재정의하고 있다면, 재정의된 run() 메소드가 호출 된다.

```

<br>
<br>

## 7.9 객체 타입 확인
&nbsp; 매개변수의 다형성에서 실제로 어떤 객체가 매개값으로 제공되었는지 확인하는 방법이 있다. 꼭 매개변수가 아니더라도 변수가 참조하는 객체의 타입을 확인하고자 할때,  `instanceof 연산자`를 사용 할수 있다. 
<br>
```
boolean result = 객체 instanceof 타입;
// 좌항의 객체가 우항의 타입이면 true 아니면 false;
```

<br>
<br>

## 7.10 추상 클래스
&nbsp; 사전적 의미로 추상은 실체 간에 공통되는 특성을 추출한것을 말한다. 예를 들어 새, 곤충, 물고기 등의 공통점은 동물이다. 여기서 동물은 실체들의 공통되는 특성을 가지고 있는 추상적인 것이라고 볼 수 있다.
<br>
<br>

### <center>추상 클래스란?</center>
&nbsp; 객체를 생성할 수 있는 클래스를 실체 클래스라고 한다면, 이 클래스들의 공통적인 필드나 메소드를 추출해서 선언한 클래스를 추상 클래스라고 한다. 추상 클래스는 실체 클래스의 부모 역활을 한다.
따라서 실체 클래스는 추상 클래스를 상속해서 공통적인 필드나 메소드를 물려받을 수 있다.

 > 추상 클래스는 실체 클래스의 공통되는 필드와 메소드를 추출해서 만들었기 때문에 new 연산자를 사용해서 객체를 직접 생성할 수 없다.


 ```
Animal animal = new Animal(); //불가능
 ```


 <br>

 추상 클래스는 새로운 실체 클래스를 만들기 위한 부모 클래스로만 사용된다. 즉 추상 클래스는 extends 뒤에만 올수 있다.

<br>
<br>


### <center>추상 클래스 선언</center>
 &nbsp; 클래스 선언에 abstract 키워드를 붙이면 추상 클래스 선언이 된다. 추상 클래스는 new 연산자를 사용할수 없다.

<br>

 ```
public abstract class 클래스명{
  //필드
  //생성자
  //메소드
}
 ```

<br>
<br>

### <center>추상 메소드 선언</center>
 &nbsp; 자식 클래스들이 가지고 있는 공통 메소드를 뽑아내어 추상 클래스를 만들때, 메소드 선언부만 동일하고 실행 내용은 자식 클래스마다 다른 경우가 많다. 이런 경우 추상 클래스는 다음과 같이 추상 메소드를 선언할수 있다. 일반 메소드 선언과의 차이점은 abstract 키워드가 붙고 메소드 실행 내용인 중괄호 가 없다.
<br>
<br>

 ```
abstract 리턴타입 메소드명(매개변수);
 ```

<br>
<br>

## 7.11 봉인된 클래스
&nbsp; 기본적으로 final 클래스를 제외한 모든 클래스는 부모 클래스가 될 수 있다. 그러나 Java15부터는 무분별한 자식 클래스 생성을 방지하기 위해서 봉인된(sealed) 클래스가 도입되었다.

```
public sealed class Person permits Employee, Manager{...}

//sealed 키워드를 사용하면 permits 키워드 뒤에 상속 가능한 자식 클래스를 지정해야 한다.

public final class Employee extends Person{}

public non-sealed class Manager extends Person{}

//봉이된 클래스를 상속하는 자식은 final 또는 non-sealed 키워드를 선언해야 한다.
```

<br>
<br>

# 마무리
&nbsp; *이것이 자바다* 7장 정리 완료, 다형성의 중심이 되는 상속에 관한 내용이 주를 이루었다. 사실 자세히 모르는 부분이기도 했고, 워낙 내용이 많기 때문에, 정리할 부분이 많았다. 사실 전체내용이 정리 대상인건 비밀.. 회를 거듭할수록 분량이 포스팅 내용이 많아 지는 것은 내가 모르는 것들이 너무 많기 때문이겠지.... 







