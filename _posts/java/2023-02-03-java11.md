---
published: true
title : "[이것이 자바다] 자바 Reminding(11) - 멀티 스레드"
categories:
  - Java
tags:
  - Study
  - Java
toc: true
toc_sticky: true
sidebar:
    nav: "sidebar-category"
---

#  [14장] 멀티 스레드 

## 14.1 멀티 스레드 개념
&nbsp; 하나의ㅏ 프로세스가 두 가지 이상으 ㅣ작업을 처리할 수 있는 이유는 멀티스레드가 있기 때문이다. 스레드는 코드의 실행 흐름을 말하는데, 프로세스 내에 스레드가 두 개라면 두 개의 코드 실행 흐름이 생긴다는 의미이다. 멀티 프로세스들은 서로 독립적이므로 하나의 프로세스에서 오류가 발생해도 다른 프로세스에게 영향을 미치지 않는데. 하지만 멀티 스레드는 프로세스 내부에서 애성되기 때문에 하나의 스레드가 예외를 발생시키면 프로세스가 종료되므로 다른 스레드에게 영향을 미친다. 그렇기 때문에 멀티 스데르를 사용할 경우에는 예외 처리에 만전을 기해야 한다.

<br>
<br>

## 14.2 메인 스레드
&nbsp; 모든 자바 프로그램은 메인 스레드가 main() 메소드를 실행하면서 지가된다. 메인 스레드는 main() 메소드의 첫 코드부터 순차적으로 실행하고, main()메소드의 마지막 코드를 실행하거나 return 문을 만나면 실행을 종료한다.
싱글 스레드에서는 메인 스레드가 종료되면 프로세스도 종료된다. 하지만 멀티 스레드에서는 실행중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다.

<br>
<br>

## 14.3 작업 스레드 생성과 실행
&nbsp; 멀티 스레드로 실행하는 프로그램을 개발하려면 먼저 몇 개의 작업을 병렬로 실행할지 결정하고 스레드를 생성해야 한다. 자바 프로그램은 메인 스레드가 반드시 존재하기 때문에 메인 작업 외의 추가적인 작업 수 만큼 스레드를 생성하면된다. Thread 클래스를 직접 객체로 생성해도 되지만, 하위 클래스를 만들어 생성할 수도 있다.

<br>

### Thread 클래스로 직접 생성
&nbsp; java.lang 패키지에 있는 Thread 클래스로부터 작업 스레드 객체를 직접 생성하려면 다음과 같이 Runnable 구현 객체를 매개값으로 갖는 생성자를 호출하면 된다.

```
Thread thread = new Thread(Runnable target);
```

Runnable에는 run() 메소드가 정의도어 있는데, 구현 클래스는 run()을 재정의해서 스레드가 실행할 코드를 가지고 있어야 한다.

```
class Task implements Runnable{
  @Override
  public void run(){
    //스레드가 실행할 코드
  }
```

Runnable 구현 클래스는 작업 내용을 정의한 것이므로, 스레드에게 전달해야 한다.

```
Runnable task = new Task();

Thread thread = new Thread(task);
```

**명시적인 Runnable 구현 클래스를 작성하지 않고 Thread 생성자를 호출할 때 Runnable 익명 구현 객체를 매개값으로 사용할수 있다. 오히려 이 방법이 더 많이 사용된다.**

```
Thread thread = new Thread(new Runnable(){
  @Override
  public void run(){
    //스레드가 실행할 코드
  }
} );
```

작업 스레드 객체가 생성되었다고해서 바로 작업 스레드가 실행되지는 않는다. 작업 스레드를 실행하려면 스레드 객체의 start() 메소드를 다음과 같이 호출해야 한다.

```
thread.start();
```

<br>
<br>

### Thread 자식 클래스로 생성
&nbsp; 작업 스레드 객체를 생성하는 또 다른 방법은 Thread의 자식 객체로 만드는 것이다. Thread 클래스를 상속한 다음 run() 메소드를 재정의해서 스레드가 실행할 코드를 작성하고 객체를 생성한다.

```
public class WorkerThread extends Thread{
  @Override
  public void run(){
    //스레드가 실행할 코드
  }
}

//스레드 객체 생성
Thread thread = new WorkerThread();
```

<br>

**명시적인 자식 클래스를 정의하지 않고, 다음과 같이 Thread 익명객체를 사용할 수도 있다. 이 방법이 더 많이 사용된다.**

```
Thread thread new Thread(){
  public void run(){
    //스레드가 실행할 코드
  }
};

thread.start();
```


<br>

## 14.4 스레드 이름
&nbsp;스레드는 자신의 이름을 가지고 있다. 메인 스레드는 main이라는 이름을 가지고 있고, 작업 스레드는 자동적으로 Thread-n이라는 이름을 가진다. 다른 이름을 설정하고 싶으면 setName() 메소드 사용.

<br>
<br>

## 14.5 스레드 상태
&nbsp; 스레드 객체를 *생성(NEW)* 하고 , start() 메소드를 호출하면 바로 실행 되는것이 아니라 *실행대기상태(RUNNABLE)*이 된다. 실행 대기하는 스레드는 CPU 스케쥴링에 따라 CPU를 점유하고  run() 메소드를 실행한다. 이때를 *실행(RUNNING)* 상태라고 한다.실행 스레드는 run() 메소드를 모두 실행하기 전에 스케쥴링에 의해 다시 대기 상태로 돌아갈 수 있다. 그리고 다른 스레드가 실행 상태가 된다. 이렇게 **스레드는 실행 대기 상태와 실행 상태를 번갈아 가면서 자신의 run() 메소드를 조금씩 실행한다.** 실행 상태에서 run() 메소드가 종료되면 더 이상 실행할 코드가 없기 때문에 스레드의 실행은 멈추게 된다. 이 상태를 *종료상태(TERMINATED)* 라고 한다.

<br>

일시 정지로 보내는 메소드
  * sleep*(long mills) : 주어진 시간 동안 스레드를 일시정지 상태로 만든다. 주어진 시간이 지나면 자동적으로 실행 대기 상태가 된다.
  * join() :  join()메소드를 호출한 스레드는 일시 정지 상태가 된다. 실행 대기 상태가 되려면, join() 메소드를 가진 스레드가 종료되어야 한다.
  * wait() : 동기화 블록 내에서 슬레드를 일시 정지 상태로 만든다.

<br>

일시 정지에서 벗어나는 메소드
  * interrupt() : 일시 정지 상태일 경우,  InterruptException을 발생시켜 실행 대기 상태 또는 종료 상태로 만든다.
  * notify(), notifyAll() : wait() 메소드로 인해 일시 정지 상태인 스레드를 실행 대기 상태로 만든다.

<br>

실행 대기로 보내는 메소드
  * yield() : 실행 상태에서 스레드에게 실행을 양보하고 실행 대기 상태가 된다.


### 주어진 시간동안 일시 정지

```
try{
  Thread.sleep(1000);
}catch(InterruptedException e){
  // interrupt() 메소드가 호출되면 실행

```

일시 정지 상태에서는 InterruptedException이 발생할 수 있기 때문에 sleep()은 예외 처리가 필요한 메소드이다.

<br>

### 다른 스레드의 종료를 기다림

```
// ThreadA
threadB.start();  // 스레드 B 실행
threadB.join();  // 스레드 B가 끝날때까지 스레드A는 대기한다. 
/


//ThreadB
run(){

}   // run() 메소드 종료 이후 다시 스레드A를 이어나간다.
```

<br>


### 다른 스레드에게 실행 양보

```
public void run(){
  while(true){
    if(work){
      System.out.println("threadA 작업 내용)"
    }else{
      Thread.yield();
  }
}
```

<br>

## 14.6 스레드 동기화
&nbsp; 멀티 스레드는 하나의 객체를 공유해서 작업할 수도 있다. 이 경우, 다른 스레드에 의해 객체 내부 데이터가 쉽게 변경될 수 있기 때문에 의도했던 것과는 다른 결과가 나올 수 있다. 이를 위해 자바는 동기화 메소드와 블록을 제공한다. 객체 내부에 동기화 메소드와 동기화 블록이 여러개 있다면 스레드가 이들 중 하나를 실행할 때 다른 스레드는 해당 메소드는 물론이고 다른 동기화 메소드 및 블록도 실행할 수 없다. 하지만 일반 메소드는 실행이 가능하다.

<br>

### 동기화 메소드 및 블록선언

```
public synchronized void method(){
  //단 하나의 스레드만 실행하는 영역
}
```
스레드가 동기화 메소드를 실행하는 즉시 객체는 잠금이 일어나고, 메소드 실행이 끝나면 잠금이 풀린다. 메소드 전체가 아닌 일부 영역을 실행할 때만 객체 잠금을 걸수도 있다.

```
public void method(){
  // 여러 스레드가 실행할 수 있는 영역

  synchronized(공유객체){
    // 단 하나의ㅏ 스레드만 실행하는 영역
  }

  // 여러 스레드가 실행할 수 있는 영역
}
```

<br>

## 14.7 스레드 안전 종료
&nbsp; 스레드는 자신의 run() 메소드가 모두 실행되면 자동으로 종료되지만, 경우에 따라 실행 중인 스레드를 즉시 종료할 필요가 있다. Thread는 stop() 메소드를 제공하고 있으나 이 메소드는 deprecated 되었다. 그 이유는 스레드를 갑자기 종료하게 되면 사용 중이던 리소스들이 불안전한 상태로 남겨지기 때문이다. 스레드를 안전하게 종료하는 방법은 사용하던 리소스들을 정리하고 run()메소드를 빨리 종료하는 것이다. 주로 조건 이용 방법과 interrupt() 메소드 이용 방법을 사용한다.


<br>

### 조건 이용
&nbsp; 스레드가 while 문으로 반복 실행할 경우, 조건을 이용해서 run() 메소드의 종료를 유도할 수 있다.


### interrupt()메소드 이용
&nbsp; interrupt() 메소드는 스레드가 일시 정지 상태에 있을 때 InterruptedException 예외를 발생시키는 역할을 한다. 이것을 이용하면 예외 처리를 통해 run() 메소드를 정상 종료시킬 수 있다.

<br>


## 14.8 데몬 스레드
&nbsp; 데몬(daemon) 스레드는 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드이다. 주 스레드가 종료되면 데몬 스레드도 따라서 자동 종료된다. 예를 들면 워드프로세서의 자동 저장, 미디어플레이어의 동영상 및 음악 재생 등이 있다. 스레드를 데몬으로 만들기 위해서는 주 스레드가 데몬이 될 스레드의 setDaemon(true)를 호출하면 된다.


<br>


## 14.9 스레드 풀
&nbsp; 병렬 작업 처리가 많아지면 스레드의 개수가 폭증하여 cpu가 바빠지고 메모리 사용량이 늘어난다. 이에 따라 애플리케이션의 성능 또한 급격히 저하된다. 이렇게 병렬 작업 증가로 인한 스레드의 폭증을 막으려면 스레드풀을 사용하는 것이 좋다.
&nbsp; 스레드풀은 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 작업 큐에 들어오는 작업들을 스레드가 하나씩 맡아 처리하는 방식이다. 작업 처리가 끝난 스레드는 다시 작업 큐에서 새로운 작업을 가져와 처리한다. 이렇게 하면 작업량이 증가해도 스레드의 개수가 늘어나지 ㅇ낳아 애플리케이션의 성능이 급격히 저하되지 않는다.

<br>


### 스레드풀 생성
&nbsp; 자바는 스레드풀을 생성하고 사용할 수 있도록 java.util.concurrent 패키지에서 ExecutorService 인터페이스와 Executors 클래스를 제공하고 있다. Executors의 다음 두 정적 메소드를 이요해서 간단하게 스레드풀인 ExecutorService 구현 객체를 만들수 있다.

* new CachedThreadPool() : 초기수0, 코어수0, 최대수 Integer.Max_Value
* newFixedThreadPool(int nThreads) : 초기수 0, 코어수 생성된수, 최대수 nThreads

초기 수는 스레드 풀이 생성될 때 기본적으로 생성되는 스레드 수를 말하고, 코어 수는 스레드가 증가된 후 사용되지 않는 스레드를 제거할 때 최소한 풀에서 유지하는 스레드 수를 말한다. 그리고 최대 수는 증가되는 스레드의 한도 수이다.

```
ExecutorService executorService = Executors.newCachedThreadPool();
// 초기수와 코어수는 0개 이고 작업 개수가 많아지면 새 스레드를 생성시켜 작업함, 60초 동안 스레드가 아무 작업을 하지 않으면 스레드를 풀에서 제거한다.

ExecutorService executorService = Executors.newFixedThreadPool(5);
//초기 수는 0개 작업 개수는 많아 지면 최대 5개 까지 스레드를 생성시킴, 이 스레드풀의 특징은 생성된 스레드를 제거하지 않는다는 것이다
```


```
ExecutorService threadPool = new ThreadPoolExecutor(
  3,                                              // 코어 스레드 개수
  100,                                         // 최대 스레드 개수
  120L,                                       // 놀고 있는 시간
  TimeUnit.SECONDS,               // 놀고 있는 시간 단위
  new SynchronousQueue<Runnable>()    //작업 큐
);
```

<br>
<br>

### 스레드풀 종료
&nbsp; 스레드풀의 스레드는 기본적으로 데몬 스레드가 아니기 때문에 main 스레드가 종료되더라도 작업을 처리하기 위해 계속 실행 상태로 남아 있다. 스레드풀의 모든 스레드가 종료하려면 ExecutorService의 다음 메소드 중 하나를 실행해야 한다.

* void shutdown() - 현재 처리 중인 작업뿐만 아니라 작업 큐에 대기하고 있는 모든 작업을 처리한 뒤에 스레드풀을 종료시킨다.
* List<Runnable> shutdownNow() - 현재 작업 처리 중인 스레드를 interrupt해서 작업을 중지시키고 스레드풀을 종료시킨다. 리턴값은 작업 큐에 있는 미처리된 작업(Runnable)의 목록이다.

<br>

### 작업 생성과 처리 요청
&nbsp; 하나의 작업은 Runnable 또는 Callable 구현 클래스로 표현한다. 둘의 차이점은 작업 처리 완료후 리턴값이 있느냐 없느냐의 차이다

```
new Runnable(){
  @Override
  public void run(){
    //스레드가 처리할 작업 내용
  }
}

new Callable<T>{
  @Override
  public T call() throws Exception{
    //스레드가 처리할 작업 내용
    return T;
  }
}
```

작업 처리 요청이란 ExecutorService의 작업 큐에 Runnable 또는 Callable 객체를 넣는 행위를 말한다. 다음 메소드르 제공한다.

* void execute(Runnable command) - Runnable을 ㅈ가업 큐에 저장, 작업 처리 결과를 리턴하지 않음
* Future<T> submit(Callable<T> task) - Callable을 작업 큐에 저장, 작업 처리 결과를 얻을 수 있도록 Future를 리턴


<br>


# 마무리
&nbsp; *이것이 자바다* 14장 정리 완료. 스레드에 대한 정리 완료, 자바를 활용한 간단한 게임을 구현할때, 공부하고 적용해본 기억들이 나는데, 이렇게 자세하게 까지 공부해 보기는 처음이다. 모르는 부분도 많고 신기한 부분도 많았던 부분, 어플리케이션을 코딩하기 위해서는 필수로 알아야 할것 같으니 잘 공부해두자!










